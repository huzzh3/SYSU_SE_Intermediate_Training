# 实训总结报告

* 学号：18327034

* 姓名：胡泽钊

* 年级：2019级
* 专业：软件工程

---

## 第一阶段

经过将近一个月的实训，收获很多，在第一阶段的时候，主要还是让大家熟悉 `Java` 语言的编写和 `Java` 工具的使用，如 `Junit` 和 `SonarQube` 。

好在我本身有一点点的 `Java` 基础，在写程序这一方面倒没有什么问题，计算器和 `HelloWorld` 程序都在半个小时内完成了。

真正有困难的还是 `Junit` 和 `SonarQube` ，`Junit` 本身并不困难，困难的是如何把它嵌入 `SonarQube` 中，由于我没有使用实验室给的云电脑，故我需要从头配置 `SonarQube` ，该过程也遇到了不少困难，好在 `google` 上有不少教程可以参考，让我很快就可以搭配好环境，并在本地浏览器上就可以访问（`localhost:9000`）

然而，我以为配置好环境就可以顺利结束这一个阶段了，然而我还是太天真，打开 `SonarQube` 之后，那一串串英文符号，让我眼花缭乱，我甚至不知道如何用它来测试代码。然后我就去 `YouTube` 上找视频教程。

第一个教程让我下载 `Eclipse` 中的 `SonarLint` 插件，然而，国内环境下载插件速度实在太慢，我愣是等了一个下午都没有下完，看着那个将近 `2~3 kb/s` 的速度我陷入了沉思，于是我决定换另外一种方法。

第二个教程让我直接创建 `Maven Project` 即可，创建好了之后，写好源代码，然后在 `SonarQube` 创建好 `token` ，接着就会给出指令，直接在本地文件下运行（含有 `pom.xml` 的文件夹）就行。

然而事情还是不顺利，第一次运行，终端提示我的编译器版本太低，后面查了才发现要在 `pom.xml` 中填入以下语句：

```xml
<properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
</properties>
```

此时，就可以通过 `SonarQube` 检查代码了， `SonarQube` 也从多维度分析我的代码，并给出了很多修改意见，让我的代码免于 `bug` 泛滥。

---

## 第二阶段

可以认为第二阶段就正式开始了实训，第二阶段持续时间也比较长。

在第二阶段，我们要在 `gridworld` 的基础上进行分析和修改，然而在回答问答题的时候，我发现我犯了个大错。实训要求在回答问题的时候，指出该问题所对应的源代码的位置。

然而，我在查找源代码的时候，看的都是 `gridworld.jar` 中的 `Java` 中间代码，即**字节码**，导致我回答问题的时候，贴的代码都是**字节码**！！！！！我没有意识到源代码其实在 `GridWorldCode` 文件夹下有给出，导致我甚至在这个实训期间学习了一下字节码的语义，也间接导致了我花费了很多时间在问答题的回答上，现在回想起来，还是觉得自己太粗心了，不检查官方给的源文件就直接上手回答。

第二阶段的写代码也比较简单，都是在原有代码基础上进行修改，只需要读懂官方给的 `api` 就能很好的实现要求了。

然而，我的 `SonarQube` 又不行了，它说它找不到我的 `gridworld.jar`，后面也折腾了很久，才发现需要先运行以下命令：

```
mvn install:install-file -Dfile=src/lib/gridworld.jar -DgroupId=gridworld -DartifactId=gridworld -Dversion=1.0 -Dpackaging=jar
```

然后在 `pom.xml` 文件中添加以下语句：

```xml
<dependency>
    <groupId>gridworld</groupId>
    <artifactId>gridworld</artifactId>
    <version>1.0</version>
</dependency>
```

这个时候再把代码提交到 `SonarQube` 就能正常分析了。

---

## 第三阶段

最后一个阶段就是第三阶段了，个人认为第三阶段中的图像处理和 `MazeBug` 比较困难，，而 `N-Puzzle` 我个人感觉比较简单，代码量比较小。

图像处理要求我们不能使用 `Java` 自带的 `api` 读取 `bmp` 文件，这也就要求我们以字节形式读取文件，然后一个字节一个字节地分析该文件，然后再将 `bmp` 图像的内容 "画" 出来，大部分时间是用在文件信息解读上的，一旦明白了 `bmp` 文件的构成，图像处理这一部分就很好做了。

`MazeBug` 就是要在 `gridWorld` 的基础上实现一个可以走迷宫的 `bug` ，我选择了使用 `.jar` 文件的方式进行迷宫读取，所以我还需要自己用 `ant` 来修改编译出 `.jar` 文件，如果直接用 `ant` 编译的话，会报错，需要把 `javac` 的 `target` 改成 `1.8` ，然后把对应文件拖到 `framework` 下就可以编译出来了。

`MazeBug` 是要用深度优先搜索来走迷宫，深度优先搜索本身不难，难得是如何维护你的“树(crossLocation)”，我的维护方式比较独特，有岔路的时候我就往“树”中添加一个新节点，没岔路我就不加新节点，一旦走到死路，就回到上一个岔路（即上一个节点）即可。弄清楚了这个原理，做完这一部分就水到渠成了。

`N-Puzzle` 也是 `N 数码问题`，题目要求我们使用广度优先搜索和 A* 算法实现，由于已经给了大部分源代码，所以只需要在源代码的基础上稍作修改。

好在 `Java` 自带了 `Queue` ，所以 `BFS` 写起来还是很快的，根据官方文档的思路，100 行内就可以写出来 `BFS`。

而 `A*` 算法也不需要我们完全实现，只需要修改其中的代价函数即可，我使用的代价函数是 `f = h + g`，其中的 `h` 是曼哈顿距离的和，`g` 是原来的估计函数的值，在这个新的代价函数的基础上，可以高效地计算出完成 `N 数码问题`。

唯一美中不足的就是，在运行 `RunnerPart2` 的过程中，**少数情况下**会出现遍历节点超过 29000 的情况，我个人感觉应该是随机出的题目错序程度太高导致的。

---

## 结语

这次实训收获很多，出的题目也很有意思，经过了将近一个月的实训，感觉自己的码力也得到了锻炼，让自己在未来的写代码的过程越来越熟练，越来越顺利。

---

